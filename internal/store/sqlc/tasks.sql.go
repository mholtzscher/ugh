// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package sqlc

import (
	"context"
	"database/sql"
	"strings"
)

const completeTasks = `-- name: CompleteTasks :execrows
UPDATE tasks
SET
  prev_state = CASE WHEN state != 'done' THEN state ELSE prev_state END,
  state = 'done',
  completed_at = ?,
  updated_at = ?
WHERE id IN (/*SLICE:ids*/?)
`

type CompleteTasksParams struct {
	CompletedAt sql.NullInt64 `json:"completed_at"`
	UpdatedAt   int64         `json:"updated_at"`
	Ids         []int64       `json:"ids"`
}

func (q *Queries) CompleteTasks(ctx context.Context, arg CompleteTasksParams) (int64, error) {
	query := completeTasks
	var queryParams []interface{}
	queryParams = append(queryParams, arg.CompletedAt)
	queryParams = append(queryParams, arg.UpdatedAt)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	result, err := q.db.ExecContext(ctx, query, queryParams...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteMeta = `-- name: DeleteMeta :exec
DELETE FROM task_meta WHERE task_id = ?
`

func (q *Queries) DeleteMeta(ctx context.Context, taskID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMeta, taskID)
	return err
}

const deleteTaskContextLinks = `-- name: DeleteTaskContextLinks :exec
DELETE FROM task_context_links WHERE task_id = ?
`

func (q *Queries) DeleteTaskContextLinks(ctx context.Context, taskID int64) error {
	_, err := q.db.ExecContext(ctx, deleteTaskContextLinks, taskID)
	return err
}

const deleteTaskProjectLinks = `-- name: DeleteTaskProjectLinks :exec
DELETE FROM task_project_links WHERE task_id = ?
`

func (q *Queries) DeleteTaskProjectLinks(ctx context.Context, taskID int64) error {
	_, err := q.db.ExecContext(ctx, deleteTaskProjectLinks, taskID)
	return err
}

const deleteTasks = `-- name: DeleteTasks :execrows
DELETE FROM tasks
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteTasks(ctx context.Context, ids []int64) (int64, error) {
	query := deleteTasks
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	result, err := q.db.ExecContext(ctx, query, queryParams...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const ensureContext = `-- name: EnsureContext :one
INSERT INTO contexts (
  name,
  created_at,
  updated_at
) VALUES (
  ?, ?, ?
)
ON CONFLICT(name) DO UPDATE SET
  updated_at = excluded.updated_at
RETURNING id
`

type EnsureContextParams struct {
	Name      string `json:"name"`
	CreatedAt int64  `json:"created_at"`
	UpdatedAt int64  `json:"updated_at"`
}

func (q *Queries) EnsureContext(ctx context.Context, arg EnsureContextParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, ensureContext, arg.Name, arg.CreatedAt, arg.UpdatedAt)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const ensureProject = `-- name: EnsureProject :one
INSERT INTO projects (
  name,
  notes,
  created_at,
  updated_at
) VALUES (
  ?, '', ?, ?
)
ON CONFLICT(name) DO UPDATE SET
  updated_at = excluded.updated_at
RETURNING id
`

type EnsureProjectParams struct {
	Name      string `json:"name"`
	CreatedAt int64  `json:"created_at"`
	UpdatedAt int64  `json:"updated_at"`
}

func (q *Queries) EnsureProject(ctx context.Context, arg EnsureProjectParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, ensureProject, arg.Name, arg.CreatedAt, arg.UpdatedAt)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getTask = `-- name: GetTask :one
SELECT
  id,
  state,
  prev_state,
  CAST(title AS TEXT) AS title,
  CAST(notes AS TEXT) AS notes,
  due_on,
  waiting_for,
  completed_at,
  created_at,
  updated_at
FROM tasks
WHERE id = ?
`

type GetTaskRow struct {
	ID          int64          `json:"id"`
	State       string         `json:"state"`
	PrevState   sql.NullString `json:"prev_state"`
	Title       string         `json:"title"`
	Notes       string         `json:"notes"`
	DueOn       sql.NullString `json:"due_on"`
	WaitingFor  sql.NullString `json:"waiting_for"`
	CompletedAt sql.NullInt64  `json:"completed_at"`
	CreatedAt   int64          `json:"created_at"`
	UpdatedAt   int64          `json:"updated_at"`
}

func (q *Queries) GetTask(ctx context.Context, id int64) (GetTaskRow, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i GetTaskRow
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.PrevState,
		&i.Title,
		&i.Notes,
		&i.DueOn,
		&i.WaitingFor,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertMeta = `-- name: InsertMeta :exec
INSERT INTO task_meta (task_id, key, value) VALUES (?, ?, ?)
`

type InsertMetaParams struct {
	TaskID int64  `json:"task_id"`
	Key    string `json:"key"`
	Value  string `json:"value"`
}

func (q *Queries) InsertMeta(ctx context.Context, arg InsertMetaParams) error {
	_, err := q.db.ExecContext(ctx, insertMeta, arg.TaskID, arg.Key, arg.Value)
	return err
}

const insertTask = `-- name: InsertTask :one
INSERT INTO tasks (
  state,
  prev_state,
  title,
  notes,
  due_on,
  waiting_for,
  completed_at,
  created_at,
  updated_at
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING
  id,
  state,
  prev_state,
  CAST(title AS TEXT) AS title,
  CAST(notes AS TEXT) AS notes,
  due_on,
  waiting_for,
  completed_at,
  created_at,
  updated_at
`

type InsertTaskParams struct {
	State       string         `json:"state"`
	PrevState   sql.NullString `json:"prev_state"`
	Title       string         `json:"title"`
	Notes       string         `json:"notes"`
	DueOn       sql.NullString `json:"due_on"`
	WaitingFor  sql.NullString `json:"waiting_for"`
	CompletedAt sql.NullInt64  `json:"completed_at"`
	CreatedAt   int64          `json:"created_at"`
	UpdatedAt   int64          `json:"updated_at"`
}

type InsertTaskRow struct {
	ID          int64          `json:"id"`
	State       string         `json:"state"`
	PrevState   sql.NullString `json:"prev_state"`
	Title       string         `json:"title"`
	Notes       string         `json:"notes"`
	DueOn       sql.NullString `json:"due_on"`
	WaitingFor  sql.NullString `json:"waiting_for"`
	CompletedAt sql.NullInt64  `json:"completed_at"`
	CreatedAt   int64          `json:"created_at"`
	UpdatedAt   int64          `json:"updated_at"`
}

func (q *Queries) InsertTask(ctx context.Context, arg InsertTaskParams) (InsertTaskRow, error) {
	row := q.db.QueryRowContext(ctx, insertTask,
		arg.State,
		arg.PrevState,
		arg.Title,
		arg.Notes,
		arg.DueOn,
		arg.WaitingFor,
		arg.CompletedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i InsertTaskRow
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.PrevState,
		&i.Title,
		&i.Notes,
		&i.DueOn,
		&i.WaitingFor,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertTaskContextLink = `-- name: InsertTaskContextLink :exec
INSERT INTO task_context_links (task_id, context_id) VALUES (?, ?)
`

type InsertTaskContextLinkParams struct {
	TaskID    int64 `json:"task_id"`
	ContextID int64 `json:"context_id"`
}

func (q *Queries) InsertTaskContextLink(ctx context.Context, arg InsertTaskContextLinkParams) error {
	_, err := q.db.ExecContext(ctx, insertTaskContextLink, arg.TaskID, arg.ContextID)
	return err
}

const insertTaskProjectLink = `-- name: InsertTaskProjectLink :exec
INSERT INTO task_project_links (task_id, project_id) VALUES (?, ?)
`

type InsertTaskProjectLinkParams struct {
	TaskID    int64 `json:"task_id"`
	ProjectID int64 `json:"project_id"`
}

func (q *Queries) InsertTaskProjectLink(ctx context.Context, arg InsertTaskProjectLinkParams) error {
	_, err := q.db.ExecContext(ctx, insertTaskProjectLink, arg.TaskID, arg.ProjectID)
	return err
}

const listContextCounts = `-- name: ListContextCounts :many
SELECT c.name, COUNT(t.id) AS count
FROM contexts c
JOIN task_context_links tcl ON tcl.context_id = c.id
JOIN tasks t ON t.id = tcl.task_id
WHERE (? = 0 OR t.state = 'done')
  AND (? = 0 OR t.state != 'done')
GROUP BY c.name
ORDER BY c.name ASC
`

type ListContextCountsParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
}

type ListContextCountsRow struct {
	Name  string `json:"name"`
	Count int64  `json:"count"`
}

func (q *Queries) ListContextCounts(ctx context.Context, arg ListContextCountsParams) ([]ListContextCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listContextCounts, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContextCountsRow
	for rows.Next() {
		var i ListContextCountsRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContextsForTasks = `-- name: ListContextsForTasks :many
SELECT tcl.task_id, c.name
FROM task_context_links tcl
JOIN contexts c ON c.id = tcl.context_id
WHERE tcl.task_id IN (/*SLICE:ids*/?)
ORDER BY tcl.task_id, c.name
`

type ListContextsForTasksRow struct {
	TaskID int64  `json:"task_id"`
	Name   string `json:"name"`
}

func (q *Queries) ListContextsForTasks(ctx context.Context, ids []int64) ([]ListContextsForTasksRow, error) {
	query := listContextsForTasks
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContextsForTasksRow
	for rows.Next() {
		var i ListContextsForTasksRow
		if err := rows.Scan(&i.TaskID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMeta = `-- name: ListMeta :many
SELECT task_id, key, value
FROM task_meta
WHERE task_id IN (/*SLICE:ids*/?)
ORDER BY task_id
`

func (q *Queries) ListMeta(ctx context.Context, ids []int64) ([]TaskMetum, error) {
	query := listMeta
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskMetum
	for rows.Next() {
		var i TaskMetum
		if err := rows.Scan(&i.TaskID, &i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectCounts = `-- name: ListProjectCounts :many
SELECT p.name, COUNT(t.id) AS count
FROM projects p
JOIN task_project_links tpl ON tpl.project_id = p.id
JOIN tasks t ON t.id = tpl.task_id
WHERE (? = 0 OR t.state = 'done')
  AND (? = 0 OR t.state != 'done')
GROUP BY p.name
ORDER BY p.name ASC
`

type ListProjectCountsParams struct {
	Column1 interface{} `json:"column_1"`
	Column2 interface{} `json:"column_2"`
}

type ListProjectCountsRow struct {
	Name  string `json:"name"`
	Count int64  `json:"count"`
}

func (q *Queries) ListProjectCounts(ctx context.Context, arg ListProjectCountsParams) ([]ListProjectCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectCounts, arg.Column1, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectCountsRow
	for rows.Next() {
		var i ListProjectCountsRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectsForTasks = `-- name: ListProjectsForTasks :many
SELECT tpl.task_id, p.name
FROM task_project_links tpl
JOIN projects p ON p.id = tpl.project_id
WHERE tpl.task_id IN (/*SLICE:ids*/?)
ORDER BY tpl.task_id, p.name
`

type ListProjectsForTasksRow struct {
	TaskID int64  `json:"task_id"`
	Name   string `json:"name"`
}

func (q *Queries) ListProjectsForTasks(ctx context.Context, ids []int64) ([]ListProjectsForTasksRow, error) {
	query := listProjectsForTasks
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectsForTasksRow
	for rows.Next() {
		var i ListProjectsForTasksRow
		if err := rows.Scan(&i.TaskID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT
  t.id,
  t.state,
  t.prev_state,
  CAST(t.title AS TEXT) AS title,
  CAST(t.notes AS TEXT) AS notes,
  t.due_on,
  t.waiting_for,
  t.completed_at,
  t.created_at,
  t.updated_at
FROM tasks t
WHERE (? = 0 OR t.state != 'done')
  AND (? IS NULL OR t.state = ?)
  AND (? IS NULL OR EXISTS (
    SELECT 1
    FROM task_project_links tpl
    JOIN projects p ON p.id = tpl.project_id
    WHERE tpl.task_id = t.id AND p.name = ?
  ))
  AND (? IS NULL OR EXISTS (
    SELECT 1
    FROM task_context_links tcl
    JOIN contexts c ON c.id = tcl.context_id
    WHERE tcl.task_id = t.id AND c.name = ?
  ))
  AND (? IS NULL OR (
    t.title LIKE '%' || ? || '%'
    OR t.notes LIKE '%' || ? || '%'
    OR EXISTS (
      SELECT 1
      FROM task_project_links tpl
      JOIN projects p ON p.id = tpl.project_id
      WHERE tpl.task_id = t.id AND p.name LIKE '%' || ? || '%'
    )
    OR EXISTS (
      SELECT 1
      FROM task_context_links tcl
      JOIN contexts c ON c.id = tcl.context_id
      WHERE tcl.task_id = t.id AND c.name LIKE '%' || ? || '%'
    )
    OR EXISTS (
      SELECT 1
      FROM task_meta m
      WHERE m.task_id = t.id AND (
        m.key LIKE '%' || ? || '%'
        OR m.value LIKE '%' || ? || '%'
      )
    )
  ))
  AND (? = 0 OR (t.due_on IS NOT NULL AND t.due_on != ''))
ORDER BY
  CASE WHEN t.state = 'done' THEN 1 ELSE 0 END,
  CASE WHEN t.due_on IS NULL OR t.due_on = '' THEN 1 ELSE 0 END,
  t.due_on ASC,
  t.updated_at DESC
`

type ListTasksParams struct {
	Column1  interface{}    `json:"column_1"`
	Column2  interface{}    `json:"column_2"`
	State    string         `json:"state"`
	Column4  interface{}    `json:"column_4"`
	Name     string         `json:"name"`
	Column6  interface{}    `json:"column_6"`
	Name_2   string         `json:"name_2"`
	Column8  interface{}    `json:"column_8"`
	Column9  sql.NullString `json:"column_9"`
	Column10 sql.NullString `json:"column_10"`
	Column11 sql.NullString `json:"column_11"`
	Column12 sql.NullString `json:"column_12"`
	Column13 sql.NullString `json:"column_13"`
	Column14 sql.NullString `json:"column_14"`
	Column15 interface{}    `json:"column_15"`
}

type ListTasksRow struct {
	ID          int64          `json:"id"`
	State       string         `json:"state"`
	PrevState   sql.NullString `json:"prev_state"`
	Title       string         `json:"title"`
	Notes       string         `json:"notes"`
	DueOn       sql.NullString `json:"due_on"`
	WaitingFor  sql.NullString `json:"waiting_for"`
	CompletedAt sql.NullInt64  `json:"completed_at"`
	CreatedAt   int64          `json:"created_at"`
	UpdatedAt   int64          `json:"updated_at"`
}

func (q *Queries) ListTasks(ctx context.Context, arg ListTasksParams) ([]ListTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, listTasks,
		arg.Column1,
		arg.Column2,
		arg.State,
		arg.Column4,
		arg.Name,
		arg.Column6,
		arg.Name_2,
		arg.Column8,
		arg.Column9,
		arg.Column10,
		arg.Column11,
		arg.Column12,
		arg.Column13,
		arg.Column14,
		arg.Column15,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksRow
	for rows.Next() {
		var i ListTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.State,
			&i.PrevState,
			&i.Title,
			&i.Notes,
			&i.DueOn,
			&i.WaitingFor,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reopenTasks = `-- name: ReopenTasks :execrows
UPDATE tasks
SET
  state = COALESCE(prev_state, 'inbox'),
  prev_state = NULL,
  completed_at = NULL,
  updated_at = ?
WHERE id IN (/*SLICE:ids*/?)
`

type ReopenTasksParams struct {
	UpdatedAt int64   `json:"updated_at"`
	Ids       []int64 `json:"ids"`
}

func (q *Queries) ReopenTasks(ctx context.Context, arg ReopenTasksParams) (int64, error) {
	query := reopenTasks
	var queryParams []interface{}
	queryParams = append(queryParams, arg.UpdatedAt)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	result, err := q.db.ExecContext(ctx, query, queryParams...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET state = ?,
  prev_state = ?,
  title = ?,
  notes = ?,
  due_on = ?,
  waiting_for = ?,
  completed_at = ?,
  updated_at = ?
WHERE id = ?
RETURNING
  id,
  state,
  prev_state,
  CAST(title AS TEXT) AS title,
  CAST(notes AS TEXT) AS notes,
  due_on,
  waiting_for,
  completed_at,
  created_at,
  updated_at
`

type UpdateTaskParams struct {
	State       string         `json:"state"`
	PrevState   sql.NullString `json:"prev_state"`
	Title       string         `json:"title"`
	Notes       string         `json:"notes"`
	DueOn       sql.NullString `json:"due_on"`
	WaitingFor  sql.NullString `json:"waiting_for"`
	CompletedAt sql.NullInt64  `json:"completed_at"`
	UpdatedAt   int64          `json:"updated_at"`
	ID          int64          `json:"id"`
}

type UpdateTaskRow struct {
	ID          int64          `json:"id"`
	State       string         `json:"state"`
	PrevState   sql.NullString `json:"prev_state"`
	Title       string         `json:"title"`
	Notes       string         `json:"notes"`
	DueOn       sql.NullString `json:"due_on"`
	WaitingFor  sql.NullString `json:"waiting_for"`
	CompletedAt sql.NullInt64  `json:"completed_at"`
	CreatedAt   int64          `json:"created_at"`
	UpdatedAt   int64          `json:"updated_at"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (UpdateTaskRow, error) {
	row := q.db.QueryRowContext(ctx, updateTask,
		arg.State,
		arg.PrevState,
		arg.Title,
		arg.Notes,
		arg.DueOn,
		arg.WaitingFor,
		arg.CompletedAt,
		arg.UpdatedAt,
		arg.ID,
	)
	var i UpdateTaskRow
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.PrevState,
		&i.Title,
		&i.Notes,
		&i.DueOn,
		&i.WaitingFor,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
