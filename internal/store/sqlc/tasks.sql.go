// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package sqlc

import (
	"context"
	"database/sql"
	"strings"
)

const deleteContexts = `-- name: DeleteContexts :exec
DELETE FROM task_contexts WHERE task_id = ?
`

func (q *Queries) DeleteContexts(ctx context.Context, taskID int64) error {
	_, err := q.db.ExecContext(ctx, deleteContexts, taskID)
	return err
}

const deleteMeta = `-- name: DeleteMeta :exec
DELETE FROM task_meta WHERE task_id = ?
`

func (q *Queries) DeleteMeta(ctx context.Context, taskID int64) error {
	_, err := q.db.ExecContext(ctx, deleteMeta, taskID)
	return err
}

const deleteTasks = `-- name: DeleteTasks :execrows
DELETE FROM tasks
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteTasks(ctx context.Context, ids []int64) (int64, error) {
	query := deleteTasks
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	result, err := q.db.ExecContext(ctx, query, queryParams...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteTokens = `-- name: DeleteTokens :exec
DELETE FROM task_projects WHERE task_id = ?
`

func (q *Queries) DeleteTokens(ctx context.Context, taskID int64) error {
	_, err := q.db.ExecContext(ctx, deleteTokens, taskID)
	return err
}

const deleteUnknown = `-- name: DeleteUnknown :exec
DELETE FROM task_unknown WHERE task_id = ?
`

func (q *Queries) DeleteUnknown(ctx context.Context, taskID int64) error {
	_, err := q.db.ExecContext(ctx, deleteUnknown, taskID)
	return err
}

const getTask = `-- name: GetTask :one
SELECT id, done, priority, completion_date, creation_date, CAST(description AS TEXT) AS description, created_at, updated_at
FROM tasks
WHERE id = ?
`

type GetTaskRow struct {
	ID             int64          `json:"id"`
	Done           int64          `json:"done"`
	Priority       sql.NullString `json:"priority"`
	CompletionDate sql.NullString `json:"completion_date"`
	CreationDate   sql.NullString `json:"creation_date"`
	Description    string         `json:"description"`
	CreatedAt      int64          `json:"created_at"`
	UpdatedAt      int64          `json:"updated_at"`
}

func (q *Queries) GetTask(ctx context.Context, id int64) (GetTaskRow, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i GetTaskRow
	err := row.Scan(
		&i.ID,
		&i.Done,
		&i.Priority,
		&i.CompletionDate,
		&i.CreationDate,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertContext = `-- name: InsertContext :exec
INSERT INTO task_contexts (task_id, name) VALUES (?, ?)
`

type InsertContextParams struct {
	TaskID int64  `json:"task_id"`
	Name   string `json:"name"`
}

func (q *Queries) InsertContext(ctx context.Context, arg InsertContextParams) error {
	_, err := q.db.ExecContext(ctx, insertContext, arg.TaskID, arg.Name)
	return err
}

const insertMeta = `-- name: InsertMeta :exec
INSERT INTO task_meta (task_id, key, value) VALUES (?, ?, ?)
`

type InsertMetaParams struct {
	TaskID int64  `json:"task_id"`
	Key    string `json:"key"`
	Value  string `json:"value"`
}

func (q *Queries) InsertMeta(ctx context.Context, arg InsertMetaParams) error {
	_, err := q.db.ExecContext(ctx, insertMeta, arg.TaskID, arg.Key, arg.Value)
	return err
}

const insertProject = `-- name: InsertProject :exec
INSERT INTO task_projects (task_id, name) VALUES (?, ?)
`

type InsertProjectParams struct {
	TaskID int64  `json:"task_id"`
	Name   string `json:"name"`
}

func (q *Queries) InsertProject(ctx context.Context, arg InsertProjectParams) error {
	_, err := q.db.ExecContext(ctx, insertProject, arg.TaskID, arg.Name)
	return err
}

const insertTask = `-- name: InsertTask :one
INSERT INTO tasks (
  done,
  priority,
  completion_date,
  creation_date,
  description,
  created_at,
  updated_at
) VALUES (
  ?, ?, ?, ?, ?, ?, ?
)
RETURNING id, done, priority, completion_date, creation_date, CAST(description AS TEXT) AS description, created_at, updated_at
`

type InsertTaskParams struct {
	Done           int64          `json:"done"`
	Priority       sql.NullString `json:"priority"`
	CompletionDate sql.NullString `json:"completion_date"`
	CreationDate   sql.NullString `json:"creation_date"`
	Description    interface{}    `json:"description"`
	CreatedAt      int64          `json:"created_at"`
	UpdatedAt      int64          `json:"updated_at"`
}

type InsertTaskRow struct {
	ID             int64          `json:"id"`
	Done           int64          `json:"done"`
	Priority       sql.NullString `json:"priority"`
	CompletionDate sql.NullString `json:"completion_date"`
	CreationDate   sql.NullString `json:"creation_date"`
	Description    string         `json:"description"`
	CreatedAt      int64          `json:"created_at"`
	UpdatedAt      int64          `json:"updated_at"`
}

func (q *Queries) InsertTask(ctx context.Context, arg InsertTaskParams) (InsertTaskRow, error) {
	row := q.db.QueryRowContext(ctx, insertTask,
		arg.Done,
		arg.Priority,
		arg.CompletionDate,
		arg.CreationDate,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i InsertTaskRow
	err := row.Scan(
		&i.ID,
		&i.Done,
		&i.Priority,
		&i.CompletionDate,
		&i.CreationDate,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const insertUnknown = `-- name: InsertUnknown :exec
INSERT INTO task_unknown (task_id, ordinal, token) VALUES (?, ?, ?)
`

type InsertUnknownParams struct {
	TaskID  int64  `json:"task_id"`
	Ordinal int64  `json:"ordinal"`
	Token   string `json:"token"`
}

func (q *Queries) InsertUnknown(ctx context.Context, arg InsertUnknownParams) error {
	_, err := q.db.ExecContext(ctx, insertUnknown, arg.TaskID, arg.Ordinal, arg.Token)
	return err
}

const listContextCounts = `-- name: ListContextCounts :many
SELECT tc.name, COUNT(t.id) AS count
FROM task_contexts tc
JOIN tasks t ON tc.task_id = t.id
WHERE (?1 IS NULL OR t.done = ?1)
GROUP BY tc.name
ORDER BY tc.name ASC
`

type ListContextCountsRow struct {
	Name  string `json:"name"`
	Count int64  `json:"count"`
}

func (q *Queries) ListContextCounts(ctx context.Context, status interface{}) ([]ListContextCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listContextCounts, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListContextCountsRow
	for rows.Next() {
		var i ListContextCountsRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listContexts = `-- name: ListContexts :many
SELECT task_id, name FROM task_contexts WHERE task_id IN (/*SLICE:ids*/?) ORDER BY task_id
`

func (q *Queries) ListContexts(ctx context.Context, ids []int64) ([]TaskContext, error) {
	query := listContexts
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskContext
	for rows.Next() {
		var i TaskContext
		if err := rows.Scan(&i.TaskID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMeta = `-- name: ListMeta :many
SELECT task_id, key, value FROM task_meta WHERE task_id IN (/*SLICE:ids*/?) ORDER BY task_id
`

func (q *Queries) ListMeta(ctx context.Context, ids []int64) ([]TaskMetum, error) {
	query := listMeta
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskMetum
	for rows.Next() {
		var i TaskMetum
		if err := rows.Scan(&i.TaskID, &i.Key, &i.Value); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjectCounts = `-- name: ListProjectCounts :many
SELECT tp.name, COUNT(t.id) AS count
FROM task_projects tp
JOIN tasks t ON tp.task_id = t.id
WHERE (?1 IS NULL OR t.done = ?1)
GROUP BY tp.name
ORDER BY tp.name ASC
`

type ListProjectCountsRow struct {
	Name  string `json:"name"`
	Count int64  `json:"count"`
}

func (q *Queries) ListProjectCounts(ctx context.Context, status interface{}) ([]ListProjectCountsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProjectCounts, status)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListProjectCountsRow
	for rows.Next() {
		var i ListProjectCountsRow
		if err := rows.Scan(&i.Name, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProjects = `-- name: ListProjects :many
SELECT task_id, name FROM task_projects WHERE task_id IN (/*SLICE:ids*/?) ORDER BY task_id
`

func (q *Queries) ListProjects(ctx context.Context, ids []int64) ([]TaskProject, error) {
	query := listProjects
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskProject
	for rows.Next() {
		var i TaskProject
		if err := rows.Scan(&i.TaskID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTasks = `-- name: ListTasks :many
SELECT t.id, t.done, t.priority, t.completion_date, t.creation_date, CAST(t.description AS TEXT) AS description, t.created_at, t.updated_at
FROM tasks t
WHERE (?1 IS NULL OR t.done = ?1)
  AND (?2 IS NULL OR EXISTS (
    SELECT 1 FROM task_projects p WHERE p.task_id = t.id AND p.name = ?2
  ))
  AND (?3 IS NULL OR EXISTS (
    SELECT 1 FROM task_contexts c WHERE c.task_id = t.id AND c.name = ?3
  ))
  AND (?4 IS NULL OR t.priority = ?4)
  AND (?5 IS NULL OR (
    t.description LIKE '%' || ?5 || '%'
    OR EXISTS (SELECT 1 FROM task_projects p WHERE p.task_id = t.id AND p.name LIKE '%' || ?5 || '%')
    OR EXISTS (SELECT 1 FROM task_contexts c WHERE c.task_id = t.id AND c.name LIKE '%' || ?5 || '%')
    OR EXISTS (SELECT 1 FROM task_meta m WHERE m.task_id = t.id AND (m.key LIKE '%' || ?5 || '%' OR m.value LIKE '%' || ?5 || '%'))
  ))
ORDER BY CASE WHEN t.done = 1 THEN 1 ELSE 0 END, t.priority IS NULL, t.priority ASC, t.created_at DESC
`

type ListTasksParams struct {
	Status   interface{} `json:"status"`
	Project  interface{} `json:"project"`
	Context  interface{} `json:"context"`
	Priority interface{} `json:"priority"`
	Search   interface{} `json:"search"`
}

type ListTasksRow struct {
	ID             int64          `json:"id"`
	Done           int64          `json:"done"`
	Priority       sql.NullString `json:"priority"`
	CompletionDate sql.NullString `json:"completion_date"`
	CreationDate   sql.NullString `json:"creation_date"`
	Description    string         `json:"description"`
	CreatedAt      int64          `json:"created_at"`
	UpdatedAt      int64          `json:"updated_at"`
}

func (q *Queries) ListTasks(ctx context.Context, arg ListTasksParams) ([]ListTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, listTasks,
		arg.Status,
		arg.Project,
		arg.Context,
		arg.Priority,
		arg.Search,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListTasksRow
	for rows.Next() {
		var i ListTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.Done,
			&i.Priority,
			&i.CompletionDate,
			&i.CreationDate,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnknown = `-- name: ListUnknown :many
SELECT task_id, ordinal, token FROM task_unknown WHERE task_id IN (/*SLICE:ids*/?) ORDER BY task_id, ordinal
`

func (q *Queries) ListUnknown(ctx context.Context, ids []int64) ([]TaskUnknown, error) {
	query := listUnknown
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskUnknown
	for rows.Next() {
		var i TaskUnknown
		if err := rows.Scan(&i.TaskID, &i.Ordinal, &i.Token); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setDone = `-- name: SetDone :execrows
UPDATE tasks
SET done = ?, completion_date = ?, updated_at = ?
WHERE id IN (/*SLICE:ids*/?)
`

type SetDoneParams struct {
	Done           int64          `json:"done"`
	CompletionDate sql.NullString `json:"completion_date"`
	UpdatedAt      int64          `json:"updated_at"`
	Ids            []int64        `json:"ids"`
}

func (q *Queries) SetDone(ctx context.Context, arg SetDoneParams) (int64, error) {
	query := setDone
	var queryParams []interface{}
	queryParams = append(queryParams, arg.Done)
	queryParams = append(queryParams, arg.CompletionDate)
	queryParams = append(queryParams, arg.UpdatedAt)
	if len(arg.Ids) > 0 {
		for _, v := range arg.Ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(arg.Ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	result, err := q.db.ExecContext(ctx, query, queryParams...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateTask = `-- name: UpdateTask :one
UPDATE tasks
SET done = ?,
  priority = ?,
  completion_date = ?,
  creation_date = ?,
  description = ?,
  updated_at = ?
WHERE id = ?
RETURNING id, done, priority, completion_date, creation_date, CAST(description AS TEXT) AS description, created_at, updated_at
`

type UpdateTaskParams struct {
	Done           int64          `json:"done"`
	Priority       sql.NullString `json:"priority"`
	CompletionDate sql.NullString `json:"completion_date"`
	CreationDate   sql.NullString `json:"creation_date"`
	Description    interface{}    `json:"description"`
	UpdatedAt      int64          `json:"updated_at"`
	ID             int64          `json:"id"`
}

type UpdateTaskRow struct {
	ID             int64          `json:"id"`
	Done           int64          `json:"done"`
	Priority       sql.NullString `json:"priority"`
	CompletionDate sql.NullString `json:"completion_date"`
	CreationDate   sql.NullString `json:"creation_date"`
	Description    string         `json:"description"`
	CreatedAt      int64          `json:"created_at"`
	UpdatedAt      int64          `json:"updated_at"`
}

func (q *Queries) UpdateTask(ctx context.Context, arg UpdateTaskParams) (UpdateTaskRow, error) {
	row := q.db.QueryRowContext(ctx, updateTask,
		arg.Done,
		arg.Priority,
		arg.CompletionDate,
		arg.CreationDate,
		arg.Description,
		arg.UpdatedAt,
		arg.ID,
	)
	var i UpdateTaskRow
	err := row.Scan(
		&i.ID,
		&i.Done,
		&i.Priority,
		&i.CompletionDate,
		&i.CreationDate,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
