// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: tasks.sql

package sqlc

import (
	"context"
	"database/sql"
)

const deleteTaskCurrent = `-- name: DeleteTaskCurrent :exec
DELETE FROM tasks_current
WHERE id = ?
`

func (q *Queries) DeleteTaskCurrent(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, deleteTaskCurrent, id)
	return err
}

const getTask = `-- name: GetTask :one
SELECT
  id,
  state,
  prev_state,
  CAST(title AS TEXT) AS title,
  CAST(notes AS TEXT) AS notes,
  due_on,
  waiting_for,
  completed_at,
  created_at,
  updated_at,
  projects_json,
  contexts_json,
  meta_json,
  version_id
FROM tasks_current
WHERE id = ?
`

type GetTaskRow struct {
	ID           int64          `json:"id"`
	State        string         `json:"state"`
	PrevState    sql.NullString `json:"prev_state"`
	Title        string         `json:"title"`
	Notes        string         `json:"notes"`
	DueOn        sql.NullString `json:"due_on"`
	WaitingFor   sql.NullString `json:"waiting_for"`
	CompletedAt  sql.NullInt64  `json:"completed_at"`
	CreatedAt    int64          `json:"created_at"`
	UpdatedAt    int64          `json:"updated_at"`
	ProjectsJson string         `json:"projects_json"`
	ContextsJson string         `json:"contexts_json"`
	MetaJson     string         `json:"meta_json"`
	VersionID    int64          `json:"version_id"`
}

func (q *Queries) GetTask(ctx context.Context, id int64) (GetTaskRow, error) {
	row := q.db.QueryRowContext(ctx, getTask, id)
	var i GetTaskRow
	err := row.Scan(
		&i.ID,
		&i.State,
		&i.PrevState,
		&i.Title,
		&i.Notes,
		&i.DueOn,
		&i.WaitingFor,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectsJson,
		&i.ContextsJson,
		&i.MetaJson,
		&i.VersionID,
	)
	return i, err
}

const insertTaskIdentity = `-- name: InsertTaskIdentity :execresult
INSERT INTO tasks (created_at) VALUES (?)
`

func (q *Queries) InsertTaskIdentity(ctx context.Context, createdAt int64) (sql.Result, error) {
	return q.db.ExecContext(ctx, insertTaskIdentity, createdAt)
}

const insertTaskVersion = `-- name: InsertTaskVersion :one
INSERT INTO task_versions (
  task_id,
  state,
  prev_state,
  title,
  notes,
  due_on,
  waiting_for,
  completed_at,
  updated_at,
  deleted,
  projects_json,
  contexts_json,
  meta_json
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
RETURNING version_id
`

type InsertTaskVersionParams struct {
	TaskID       int64          `json:"task_id"`
	State        string         `json:"state"`
	PrevState    sql.NullString `json:"prev_state"`
	Title        string         `json:"title"`
	Notes        string         `json:"notes"`
	DueOn        sql.NullString `json:"due_on"`
	WaitingFor   sql.NullString `json:"waiting_for"`
	CompletedAt  sql.NullInt64  `json:"completed_at"`
	UpdatedAt    int64          `json:"updated_at"`
	Deleted      int64          `json:"deleted"`
	ProjectsJson string         `json:"projects_json"`
	ContextsJson string         `json:"contexts_json"`
	MetaJson     string         `json:"meta_json"`
}

func (q *Queries) InsertTaskVersion(ctx context.Context, arg InsertTaskVersionParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, insertTaskVersion,
		arg.TaskID,
		arg.State,
		arg.PrevState,
		arg.Title,
		arg.Notes,
		arg.DueOn,
		arg.WaitingFor,
		arg.CompletedAt,
		arg.UpdatedAt,
		arg.Deleted,
		arg.ProjectsJson,
		arg.ContextsJson,
		arg.MetaJson,
	)
	var version_id int64
	err := row.Scan(&version_id)
	return version_id, err
}

const listTaskVersions = `-- name: ListTaskVersions :many
SELECT
  version_id,
  task_id,
  state,
  prev_state,
  title,
  notes,
  due_on,
  waiting_for,
  completed_at,
  updated_at,
  deleted,
  projects_json,
  contexts_json,
  meta_json
FROM task_versions
WHERE task_id = ?
ORDER BY version_id DESC
LIMIT ?
`

type ListTaskVersionsParams struct {
	TaskID int64 `json:"task_id"`
	Limit  int64 `json:"limit"`
}

func (q *Queries) ListTaskVersions(ctx context.Context, arg ListTaskVersionsParams) ([]TaskVersion, error) {
	rows, err := q.db.QueryContext(ctx, listTaskVersions, arg.TaskID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskVersion
	for rows.Next() {
		var i TaskVersion
		if err := rows.Scan(
			&i.VersionID,
			&i.TaskID,
			&i.State,
			&i.PrevState,
			&i.Title,
			&i.Notes,
			&i.DueOn,
			&i.WaitingFor,
			&i.CompletedAt,
			&i.UpdatedAt,
			&i.Deleted,
			&i.ProjectsJson,
			&i.ContextsJson,
			&i.MetaJson,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertTaskCurrent = `-- name: UpsertTaskCurrent :exec
INSERT INTO tasks_current (
  id,
  state,
  prev_state,
  title,
  notes,
  due_on,
  waiting_for,
  completed_at,
  created_at,
  updated_at,
  projects_json,
  contexts_json,
  meta_json,
  version_id
) VALUES (
  ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
ON CONFLICT(id) DO UPDATE SET
  state = excluded.state,
  prev_state = excluded.prev_state,
  title = excluded.title,
  notes = excluded.notes,
  due_on = excluded.due_on,
  waiting_for = excluded.waiting_for,
  completed_at = excluded.completed_at,
  created_at = excluded.created_at,
  updated_at = excluded.updated_at,
  projects_json = excluded.projects_json,
  contexts_json = excluded.contexts_json,
  meta_json = excluded.meta_json,
  version_id = excluded.version_id
`

type UpsertTaskCurrentParams struct {
	ID           int64          `json:"id"`
	State        string         `json:"state"`
	PrevState    sql.NullString `json:"prev_state"`
	Title        string         `json:"title"`
	Notes        string         `json:"notes"`
	DueOn        sql.NullString `json:"due_on"`
	WaitingFor   sql.NullString `json:"waiting_for"`
	CompletedAt  sql.NullInt64  `json:"completed_at"`
	CreatedAt    int64          `json:"created_at"`
	UpdatedAt    int64          `json:"updated_at"`
	ProjectsJson string         `json:"projects_json"`
	ContextsJson string         `json:"contexts_json"`
	MetaJson     string         `json:"meta_json"`
	VersionID    int64          `json:"version_id"`
}

func (q *Queries) UpsertTaskCurrent(ctx context.Context, arg UpsertTaskCurrentParams) error {
	_, err := q.db.ExecContext(ctx, upsertTaskCurrent,
		arg.ID,
		arg.State,
		arg.PrevState,
		arg.Title,
		arg.Notes,
		arg.DueOn,
		arg.WaitingFor,
		arg.CompletedAt,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.ProjectsJson,
		arg.ContextsJson,
		arg.MetaJson,
		arg.VersionID,
	)
	return err
}
