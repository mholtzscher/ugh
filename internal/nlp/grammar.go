// Code generated by participle grammar. DO NOT EDIT.

package nlp

import (
	"github.com/alecthomas/participle/v2"
	"github.com/alecthomas/participle/v2/lexer"
)

// Grammar types for participle parsing - these are intermediate representation
// and get converted to the AST types (CreateCommand, UpdateCommand, etc.) in convert.go

type GCommand struct {
	Pos lexer.Position

	Create *GCreateCmd `parser:"@@"`
	Update *GUpdateCmd `parser:"| @@"`
	Filter *GFilterCmd `parser:"| @@"`
}

type GCreateCmd struct {
	Pos lexer.Position

	// Create verbs: add, create, new
	Verb  string        `parser:"@( 'add' | 'create' | 'new' )"`
	Items []GCreateItem `parser:"@@*"`
}

type GCreateItem interface {
	gCreateItem()
}

type GCreateTitle struct {
	Pos lexer.Position

	Words []string `parser:"@Ident+"`
}

func (GCreateTitle) gCreateItem() {}

type GCreateOp struct {
	Pos lexer.Position

	Op GOp `parser:"@@"`
}

func (GCreateOp) gCreateItem() {}

type GCreateRelativeDate struct {
	Pos lexer.Position

	Date string `parser:"@RelativeDate"`
}

func (GCreateRelativeDate) gCreateItem() {}

type GUpdateCmd struct {
	Pos lexer.Position

	// Update verbs: set, edit, update
	Verb string `parser:"@( 'set' | 'edit' | 'update' )"`
	// Target: "selected", "it", "this", "that", a numeric ID, or omitted (defaults to selected)
	Target string `parser:"(@Target | @Ident)?"`
	Ops    []GOp  `parser:"@@*"`
}

type GFilterCmd struct {
	Pos lexer.Position

	// Filter verbs: find, show, list, filter
	Verb string    `parser:"@( 'find' | 'show' | 'list' | 'filter' )"`
	Expr *GOrChain `parser:"@@"`
}

// GOp represents an operation (set, add, remove, clear, tag)
type GOp struct {
	Pos lexer.Position

	Set    *GSetOp    `parser:"@@"`
	Add    *GAddOp    `parser:"| @@"`
	Remove *GRemoveOp `parser:"| @@"`
	Clear  *GClearOp  `parser:"| @@"`
	Tag    *GTagOp    `parser:"| @@"`
}

type GSetOp struct {
	Pos lexer.Position

	Field string    `parser:"@SetField"`
	Value GRawValue `parser:"@@"`
}

type GAddOp struct {
	Pos lexer.Position

	Field string    `parser:"@AddField"`
	Value GRawValue `parser:"@@"`
}

type GRemoveOp struct {
	Pos lexer.Position

	Field string    `parser:"@RemoveField"`
	Value GRawValue `parser:"@@"`
}

type GClearOp struct {
	Pos lexer.Position

	Field string `parser:"(@ClearField | @ClearOp @Ident)"`
}

type GTagOp struct {
	Pos lexer.Position

	Project string `parser:"@ProjectTag"`
	Context string `parser:"| @ContextTag"`
}

// GRawValue captures a raw value that can span multiple tokens
// We capture each token separately and join them with spaces
// Include common token types that can appear in values: Ident, Verb (for words like "new"), RelativeDate, Target, Colon (for meta values), etc.
type GRawValue struct {
	Pos lexer.Position

	Quoted string   `parser:"@Quoted"`
	Tokens []string `parser:"| (@Ident | @Verb | @RelativeDate | @Target | @Colon)+"`
}

// Filter expression types - simple chain structures
type GOrChain struct {
	Pos lexer.Position

	Left  *GAndChain `parser:"@@"`
	Op    string     `parser:"( (@Or | @OrOp) )?"`
	Right *GOrChain  `parser:"@@?"`
}

type GAndChain struct {
	Pos lexer.Position

	Left  *GNotExpr  `parser:"@@"`
	Op    string     `parser:"( (@And | @AndOp) )?"`
	Right *GAndChain `parser:"@@?"`
}

type GNotExpr struct {
	Pos lexer.Position

	Not  string       `parser:"((@Not | @ClearOp) )?"`
	Atom *GFilterAtom `parser:"@@"`
}

type GFilterAtom struct {
	Pos lexer.Position

	Paren *GOrChain   `parser:"'(' @@ ')'"`
	Pred  *GPredicate `parser:"| @@"`
}

type GPredicate struct {
	Pos lexer.Position

	FieldPred *GFieldPredicate `parser:"@@"`
	TagPred   *GTagPredicate   `parser:"| @@"`
	TextPred  *GTextPredicate  `parser:"| @@"`
	IDPred    *GIDPredicate    `parser:"| @@"`
}

type GFieldPredicate struct {
	Pos lexer.Position

	Field string    `parser:"@SetField"`
	Value GRawValue `parser:"@@"`
}

type GTagPredicate struct {
	Pos lexer.Position

	Project string `parser:"@ProjectTag"`
	Context string `parser:"| @ContextTag"`
}

type GTextPredicate struct {
	Pos lexer.Position

	Value GRawValue `parser:"@@"`
}

type GIDPredicate struct {
	Pos lexer.Position

	ID string `parser:"@Ident"`
}

var dslParser = participle.MustBuild[GCommand](
	participle.Lexer(dslLexer),
	participle.Elide("Whitespace"),
	participle.Unquote("Quoted"),
	participle.Union[GCreateItem](GCreateTitle{}, GCreateOp{}, GCreateRelativeDate{}),
)
